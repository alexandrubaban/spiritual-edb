/**
 * Core compiler methods.
 */
edb.Compiler = gui.Class.create ( Object.prototype, {

	/**
	 * Compile EDBML to function source.
	 * @param {String} script
	 * @param {What?} head
	 * @returns {String}
	 */
	_compile : function ( script ) {
		var runner = new edb.Runner (); 
		var status = new edb.Status ();
		var result = new edb.Result ( '"use strict";\n' );
		runner.run ( this, script, status, result );
		status.body += ( status.mode === "html" ? "';" : "" ) + "\nreturn out.write ();";
		return this._format ( status.body );
	},

	online : function ( line, runner, status, result ) {
		line = line.trim ();
		status.last = line.length - 1;
		status.adds = line.charAt ( 0 ) === "+";
		status.cont = status.cont || ( status.mode === "html" && status.adds );
		if ( line.length > 0 ) {
			if ( !runner.firstline ) {
				if ( status.mode === "html" ) {	
					if ( !status.cont ) {
						result.body += "';\n";
						status.mode = "js";
					}
				} else {
					status.body += "\n";
				}
			}
			status.cont = false;
		}
	},

	onchar : function ( c, runner, status, result ) {
		switch ( status.mode ) {
			case "tag" :
				this._compiletag ( c, runner, status, result );
				break;
			case "html" :
				this._compilehtml ( c, runner, status, result);
				break;
			default : // @todo case "js"
				this._compilescript ( c, runner, status, result );
				break;
		}
		if ( status.skip-- <= 0 ) {
			if ( status.poke ) {
				status.func += c;
			} else {
				if ( status.mode !== "tag" ) {
					status.body += c;
				}
			}
		}
	},
	
	/**
	 * Compile character as HTML.
	 * @param {edb.State} status
	 * @param {String} c
	 * @param {number} i
	 * @param {String} line
	 */
	_compilehtml : function ( c, runner, status, result ) {
		switch ( c ) {
			case "{" :
				if ( status.peek || status.poke ) {}
				break;
			case "}" :
				if ( status.peek ) {
					status.peek = false;
					status.skip = 1;
					status.body += ") + '";
				}
				if ( status.poke ) {
					status.body = this._inject ( status.body, status.spot, status.func, status.indx++ );
					status.poke = false;
					status.func = null;
					status.skip = 1;
				}
				break;
			case "$" :
				if ( !status.peek && !status.poke && runner.ahead ( "{" )) {
					status.peek = true;
					status.skip = 2;
					status.body += "' + (";
				}
				break;
			case "#" :
				if ( !status.peek && !status.poke && runner.ahead ( "{" )) {
					status.poke = true;
					status.func = "";
					status.skip = 2;
				}
				break;
			case "+" :
				switch ( i ) {
					case 0 :
						status.skip = status.adds ? 1 : 0;
						break;
					case status.last :
						status.cont = true;
						status.skip = 1;
						break;
				}
				break;
			case "'" :
				if ( !status.peek && !status.poke ) {
					status.body += "\\";
				}
				break;
			case "@" :
				this._htmlatt ( status, line, i );
				break;
		}
	},

	/**
	 * Compile character as script.
	 * @param {edb.State} status
	 * @param {String} c
	 * @param {number} i
	 * @param {String} line
	 */
	_compilescript : function ( c, runner, status, result ) {
		switch ( c ) {
			case "<" :
				if ( runner.firstchar ) {
					var tag;
					if ( false && ( tag = this._tagstart ( line ))) {
						status.mode = "tag";
						this._aaa ( status, line, i );
					} else if ( false && ( tag = this._tagstop ( line ))) {
						status.mode = "tag"; // js ??????????????????????????????????
						this._bbb ( status );
					} else {
						status.mode = "html";
						status.spot = status.body.length - 1;
						status.body += "out.html += '";
					}
				}
				break;
			case "@" :
				//this._scriptatt ( status, line, i );
				break;
		}
	},

	_aaa : function ( status, line, i ) {
		status.body += "out.html += Tag.get ( '#ole', window )( function ( out ) {";
		var elem = new gui.HTMLParser ( document ).parse ( line + "</ole>" )[ 0 ];
		var json = JSON.stringify ( gui.AttPlugin.getmap ( elem ), null, "\t" );
		var atts = this._fixerupper ( json );
		status.conf.push ( atts );
	},

	_bbb : function ( status ) {
		status.body += "}, " + status.conf.pop () + ");";
		status.conf = null;
	},

	_fixerupper : function ( json ) {

		var status = new edb.State ();
		status.body = "";

		var lines = json.split ( "\n" );
		lines.forEach ( function ( line, index ) {
			Array.forEach ( line, function ( c, i ) {
				switch ( c ) {
					case "\"" :
						if ( !status.peek && !status.poke ) {
							if ( this._ahead ( line, i, "${" )) {
								status.peek = true;
								status.skip = 3;
							} else if ( this._ahead ( line, i, "#{" )) {
								status.poke = true;
								status.skip = 3;
								status.func = " function () {\n";
								status.spot = status.body.length - 1;
							}
						}
						break;
					case "}" :
						if ( status.peek || status.poke ) {
							if ( this._skipahead ( line, i, "\"" )) {
								if ( status.poke ) {
									status.func += "\n}";
									status.body = status.body.substring ( 0, status.spot ) + 
										status.func + status.body.substring ( status.spot );
								}
								status.peek = false;
								status.poke = false;
								status.skip = 2;
							}
						}
						break;
				}
				if ( status.skip-- <= 0 ) {
					if ( status.poke ) {
						status.func += c;
					} else {
						status.body += c;
					}
				}
			}, this );
			if ( index < lines.length - 1 ) {
				status.body += "\n";
			}
		}, this );
		return status.body; //.replace ( /"\${/g, "" ).replace ( /\}"/g, "" );
	},

	/**
	 * Compile character as tag.
	 * @param {edb.State} status
	 * @param {String} c
	 * @param {number} i
	 * @param {String} line
	 */
	_compiletag : function ( status, c, i, line ) {
		switch ( c ) {
			case "$" :
				if ( this._ahead ( line, i, "{" )) {
					status.refs = true;
					status.skip = 2;
				}
				break;
			case ">" :
				//status.tagt = false;
				status.mode = "js";
				status.skip = 1;
				break;
		}
	},

	/**
	 * Line text at index equals string?
	 * @param {String} line
	 * @param {number} index
	 * @param {String} string
	 * @returns {boolean}
	 */
	_ahead : function ( line, index, string ) {
		console.error ( "deprecated" );
		var i = index + 1, l = string.length;
		return line.length > index + l && line.substring ( i, i + l ) === string;
	},

	/**
	 * Line text before index equals string?
	 * @param {String} line
	 * @param {number} index
	 * @param {String} string
	 * @returns {boolean}
	 */
	_behind : function ( line, index, string ) {
		console.error ( "deprecated" );
		var length = string.length, start = index - length;
		return start >= 0 && line.substr ( start, length ) === string;
	},

	/**
	 * Space-stripped text at index equals string?
	 * @param {String} line
	 * @param {number} index
	 * @param {String} string
	 * @returns {boolean}
	 */
	_skipahead : function ( line, index, string ) {
		console.error ( "deprecated" );
		line = line.substr ( index ).replace ( / /g, "" );
		return this._ahead ( line, 0, string );
	},

	/**
	 * @todo
	 * Space-stripped text before index equals string?
	 * @param {String} line
	 * @param {number} index
	 * @param {String} string
	 * @returns {boolean}
	 *
	_skipbehind : function ( line, index, string ) {
		return this._behind ( line.replace ( / /g, "" ), index, string );
	},
	*/

	/**
	 * Tag start?
	 * @param {String} line
	 */
	_tagstart : function ( line ) {
		return this._ahead ( line, 0, "ole" );
	},

	/**
	 * Tag stop?
	 * @param {String} line
	 */
	_tagstop : function ( line ) {
		return this._ahead ( line, 0, "/ole>" );
	},

	/*
	 * Parse @ notation in markup. 
	 * @param {String} line
	 * @param {number} i
	 */
	_htmlatt : function ( status, line, i ) {
		var attr = edb.Compiler._ATTREXP;
		var rest, name, dels, what;
		if ( this._behind ( line, i, "@" )) {}
		else if ( this._behind ( line, i, "#{" )) { alert ( line )} // onclick="#{@passed}"
		else if ( this._ahead ( line, i, "@" )) {
			status.body += "' + att._all () + '";
			status.skip = 2;
		} else {
			rest = line.substring ( i + 1 );
			name = attr.exec ( rest )[ 0 ];
			dels = this._behind ( line, i, "-" );
			what = dels ? "att._pop" : "att._out";
			status.body = dels ? status.body.substring ( 0, status.body.length - 1 ) : status.body;
			status.body += "' + " + what + " ( '" + name + "' ) + '";
			status.skip = name.length + 1;
		}
	},

	/*
	 * Parse @ notation in script.Ptag
	 * TODO: preserve email address and allow same-line @
	 * @param {String} line
	 * @param {number} i
	 */
	_scriptatt : function ( status, line, i ) {
		var attr = edb.Compiler._ATTREXP;
		var rest, name;
		if ( this._behind ( line, i, "@" )) {} 
		else if ( this._ahead ( line, i, "@" )) {
			status.body += "var att = new edb.Att ();";
			status.skip = 2;
		} else {
			rest = line.substring ( i + 1 );
			name = attr.exec ( rest )[ 0 ];
			if ( name ) {
				status.body += rest.replace ( name, "att['" + name + "']" );
				status.skip = rest.length;
			} else {
				throw "Bad @name: " + rest;
			}
		}
	},

	/**
	 * Generate and inject poke function into main function body.
	 * @param {String} body
	 * @param {number} spot
	 * @param {String} func
	 * @returns {String}
	 */
	_inject : function ( body, spot, func, index ) {
		var sig = this._signature ?  ( ", &quot;" + this._signature + "&quot;" ) : "";
		return (
			body.substring ( 0, spot ) + "\n" + 
			"var __edb__" + index + " = edb.Script.assign ( function ( value, checked ) { \n" +
			func + ";\n" +
			"}, this );" +
			body.substring ( spot ) +
			"edb.Script.register ( event ).invoke ( &quot;\' + __edb__" + index + " + \'&quot;" + sig + " );"
		);
	},

	/**
	 * Format script output.
	 * @todo Indent switch cases
	 * @todo Remove blank lines
	 * @param {String} body
	 * @returns {String}
	 */
	_format : function ( body ) {
		var result = "",
			tabs = "\t",
			first = null,
			last = null,
			fixt = null,
			flast = null;
		body.split ( "\n" ).forEach ( function ( line ) {
			line = line.trim ();
			first = line.charAt ( 0 );
			last = line.charAt ( line.length - 1 );
			fixt = line.split ( "//" )[ 0 ].trim ();
			flast = fixt.charAt ( fixt.length - 1 );
			if (( first === "}" || first === "]" ) && tabs !== "" ) {				
				tabs = tabs.slice ( 0, -1 );
			}
			result += tabs + line + "\n";
			if ( last === "{" || last === "[" || flast === "{" || flast === "[" ) {
				tabs += "\t";
			}
		});
		return result;
	}


}, {}, { // Static ............................................................................

	/**
	 * @static
	 * Matches a qualified attribute name (class,id,src,href) allowing 
	 * underscores, dashes and dots while not starting with a number.
	 * @todo https://github.com/jshint/jshint/issues/383
	 * @type {RegExp}
	 */
	_ATTREXP : /^[^\d][a-zA-Z0-9-_\.]+/

});